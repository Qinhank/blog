<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Author hank.qin1994@gmail.com"><title>从输入一个URL到回车 · Hank</title><meta name="description" content="网上很多版本，虽然大体没什么不同，但是我觉得还是不够详尽，很多地方只是提了，没有仔细说明，于是自己尝试开一个，按照自己所学到的整理一遍。
你输入的这串英文我要转成数字

当输入URL按下回车后，浏览器会根据域名查找其所对应的IP地址。  

问：那么什么是IP呢？这个IP最终指向哪里呢？
IP 协议"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/19928429.png" style="width:127px;"><h3 title=""><a href="/">Hank</a></h3><div class="description"><p>一个前端开发er</p></div></div></div><ul class="social-links"><li><a href="https://github.com/hankqin"><i class="fa fa-github"></i></a></li></ul><div class="footer"><p class="coding">Hosted by <a href="https://pages.coding.me">Coding Pages</a></p></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><!--liif is_current('links')
  a.current(href="/links")= __('Links')					
else
  a(href="/links")= __('Links')		--></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>从输入一个URL到回车</a></h3></div><div class="post-content"><p>网上很多版本，虽然大体没什么不同，但是我觉得还是不够详尽，很多地方只是提了，没有仔细说明，于是自己尝试开一个，按照自己所学到的整理一遍。</p>
<h2 id="你输入的这串英文我要转成数字"><a href="#你输入的这串英文我要转成数字" class="headerlink" title="你输入的这串英文我要转成数字"></a>你输入的这串英文我要转成数字</h2><hr>
<blockquote>
<p>当输入URL按下回车后，浏览器会根据域名查找其所对应的IP地址。  </p>
</blockquote>
<h4 id="问：那么什么是IP呢？这个IP最终指向哪里呢？"><a href="#问：那么什么是IP呢？这个IP最终指向哪里呢？" class="headerlink" title="问：那么什么是IP呢？这个IP最终指向哪里呢？"></a>问：那么什么是IP呢？这个IP最终指向哪里呢？</h4><ol>
<li>IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；  </li>
<li>根据第一点即可知道，这个IP指向的就是存放这个页面资源的电脑，我们称为服务器。   <br></li>
</ol>
<h4 id="问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？"><a href="#问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？" class="headerlink" title="问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？"></a>问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？</h4><p>一、查找过程</p>
<ol>
<li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；  </li>
<li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；  </li>
<li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；  </li>
<li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；  <ol>
<li>LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；  </li>
<li>LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；  </li>
<li>LDNS 向 baidu.com 域名服务器发起请求，得到 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的 IP 地址；  </li>
</ol>
</li>
<li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；  </li>
<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；  </li>
<li>至此，浏览器已经得到了域名对应的 IP 地址。  </li>
</ol>
<p>二、IP与域名的关系  </p>
<ul>
<li>IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；  </li>
</ul>
<h2 id="哈哈，我找到你在哪了"><a href="#哈哈，我找到你在哪了" class="headerlink" title="哈哈，我找到你在哪了"></a>哈哈，我找到你在哪了</h2><hr>
<blockquote>
<p>确定了服务器的 IP 地址后，浏览器便开始与服务器建立连接了。  </p>
</blockquote>
<p>当浏览器确定了服务器IP地址后，连接就正式开始啦。<br>服务器：可是，咱们萍水相逢，凭啥一上来就想看我包里装了什么？<br>客户端：既然如此，咱们就建立互相信任的关系吧。  <br></p>
<h4 id="建立连接-——-三次握手"><a href="#建立连接-——-三次握手" class="headerlink" title="建立连接 —— 三次握手"></a>建立连接 —— 三次握手</h4><ol>
<li>主机向服务器发送一个建立连接的请求（您好，我想认识您）；  </li>
<li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；  </li>
<li>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。  <br></li>
</ol>
<p>什么？就那么简单？NO，NO，NO，请<strong><a href="http://mp.weixin.qq.com/s/I41dnewpliUUU3VDNvPT1g" target="_blank" rel="noopener">查看这里</a></strong>详细了解这个过程。</p>
<h2 id="给我看看你背包里有什么吧"><a href="#给我看看你背包里有什么吧" class="headerlink" title="给我看看你背包里有什么吧"></a>给我看看你背包里有什么吧</h2><hr>
<blockquote>
<p>当服务器与主机建立了连接之后，主机便开始与服务器进行通信。  </p>
</blockquote>
<p>客户端：现在咱们的关系够铁了吧，来来来，看看你背包里有些啥玩意。<br>服务器：虽然我们很铁了，但是我爸爸说了，不能随便给别人看背包。<br>服务器：你说你想要啥，我拿给你。<br>客户端：。。。   <br></p>
<h3 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a><strong>网页请求与显示</strong></h3><ol>
<li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；    </li>
<li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；  </li>
<li>服务器将得到的 HTML 文件发送给浏览器；  </li>
<li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；  </li>
<li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；  </li>
</ol>
<p>网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。   </p>
<h2 id="东西拿到啦，我要开始干活啦"><a href="#东西拿到啦，我要开始干活啦" class="headerlink" title="东西拿到啦，我要开始干活啦"></a>东西拿到啦，我要开始干活啦</h2><hr>
<blockquote>
<p>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页  </p>
</blockquote>
<p>客户端：哈哈哈哈，拿到我想要的东西啦，我现在开始干活了。  <br></p>
<h3 id="浏览器解析渲染数据"><a href="#浏览器解析渲染数据" class="headerlink" title="浏览器解析渲染数据"></a><strong>浏览器解析渲染数据</strong></h3><p>要说浏览器的解析渲染，首先咱们应该了解一下浏览器的内部组件。<br>浏览器内部拥有几个组件，包括UI后端、JS解释器、网络、浏览器引擎、渲染引擎以及其它异步引擎。<br>其中，UI后端的作用就是用来绘制类似组合选择框及对话框等基本组件，其具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。<br>当浏览器获得服务器的html文件后，会进行以下几个步骤：  </p>
<font size="4"><strong>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</strong></font>   

<p>具体过程：</p>
<ol>
<li>渲染引擎开始解析html，并将标签转化为内容树中的dom节点  </li>
<li>解析外部CSS文件及style标签中的样式信息  </li>
<li>这些样式信息以及html中的可见性指令将被用来构建render树  <br><font color="gray">(Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上)</font>  </li>
<li>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标  </li>
<li>接着浏览器开始绘制，即遍历render树，并使用UI后端层绘制每个节点。<br><font color="gray">(值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容)</font>  <br></li>
</ol>
<p>那么浏览器究竟是怎么构建DOM、Render树的呢？<a href="http://blog.csdn.net/baofeidyz/article/details/60479612" target="_blank" rel="noopener">点我查看更多知识噢</a>  </p>
<h2 id="天底下没有不散的宴席"><a href="#天底下没有不散的宴席" class="headerlink" title="天底下没有不散的宴席"></a>天底下没有不散的宴席</h2><hr>
<blockquote>
<p>客户端与服务器断开连接</p>
</blockquote>
<p>服务器：我爸叫我回家吃饭了，我赶走了<br>客户端：好<br>这时客户端犹豫了半刻。。。<br>客户端：你再等等，让我想想还有没有什么漏问了<br>服务器：。。。  <br></p>
<h3 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a><strong>断开连接–四次挥手</strong></h3><ol>
<li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；  </li>
<li>服务器接到请求后发送确认收到请求的信号（知道了）；  </li>
<li>服务器向主机发送断开通知（我也该走了）；  </li>
<li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；  </li>
</ol>
<p>补充：  </p>
<ul>
<li>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。  </li>
<li>第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。  </li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-02-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术/" title="技术">技术 </a><a class="tag" href="/tags/协议-页面渲染过程/" title="协议 页面渲染过程">协议 页面渲染过程 </a></div></div></div></div><div class="share"><!--.evernotea.fa.fa-bookmark(href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&title='+encodeURIComponent(document.title);}})();", ref="nofollow", target="_blank")--><!--.weiboa.fa.fa-weibo(href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&title=',e(d.title),'&appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));")--><!--.twittera.fa.fa-twitter(href=url_for("http://twitter.com/home?status="+","+config.url+"/"+page.path+","+config.title+","+page.title+",;"))--></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/03/01/说说我理解的跨域/" title="说说我理解的跨域">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/02/14/搭一个BLOG/" title="搭一个Blog">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>