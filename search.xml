<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>技术 | 2022.01.10</title>
      <link href="/2022/01/11/%E6%8A%80%E6%9C%AF-2022-01-10/"/>
      <url>/2022/01/11/%E6%8A%80%E6%9C%AF-2022-01-10/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-01-10"><a href="#2022-01-10" class="headerlink" title="2022.01.10"></a>2022.01.10</h1><aside><br>💡 新年新气象，想立个flag——尽可能的把看过的项目嚼碎，再吐出来分享，嚼碎和吐出在过去的一年做得都非常差，所以还是希望新的一年能够超越自己，多一些好的变化。<br></aside><h1 id="2021年最受欢迎的js项目"><a href="#2021年最受欢迎的js项目" class="headerlink" title="2021年最受欢迎的js项目"></a>2021年最受欢迎的js项目</h1><p>像react、vue、vscode这些常年占据榜单的我觉得无需再多提（今年还有一个flag是学习vue3），就直接说说我学习和理解到的吧，如果你想了解完整榜单，可以<a href="https://risingstars.js.org/2021/en" target="_blank" rel="noopener">点击这里</a>了解。</p><h2 id="zx"><a href="#zx" class="headerlink" title="zx"></a><a href="https://github.com/google/zx" target="_blank" rel="noopener">zx</a></h2><p>这个项目居然是今年的榜首我是很懵的，因为我完全没听说过（也可能是我在这方面需求比较小）。</p><p>它是做什么的呢？我简单的理解下来它就是帮你实现用JS的方式去写Bash脚本。</p><p>但凡写过Bash脚本的同学都知道它的写法有多麻烦，所以用JS写确实方便很多，后续如果有需求可能会对它进行深度学习，到时候再出文章细说吧。</p><h2 id="NocoDB"><a href="#NocoDB" class="headerlink" title="NocoDB"></a><strong><a href="https://github.com/nocodb/nocodb" target="_blank" rel="noopener">NocoDB</a></strong></h2><p>这也是我第一次听说，站在我现有的理解层面上看它实际解决了数据规范与数据便捷的一个问题，不论是用它编辑数据库或者用它新增数据库都比去完全写一套系统要方便很多，而且还能强制规范每个人的输入，保证数据的规范性。</p><p>因为它的Docker版本部署实在太简单了，我花了5分钟部署并体验了一下，怎么说，好处和不足都有，好处就是真的很直观，比我用Navicat改爽多了，不足其实也很明显，就是逻辑很直白而且如果是相对excel它的便利性还是不够。</p><p>不过好处是它好像支持API调用，这样或许可以很方便的整合到其他系统。</p><h2 id="Slidev"><a href="#Slidev" class="headerlink" title="Slidev"></a><a href="https://github.com/slidevjs/slidev" target="_blank" rel="noopener">Slidev</a></h2><p>介绍说的是——为<strong>开发者</strong>打造的<strong>演示文稿</strong>工具</p><p>看了下，还挺有意思的，后面要做述职报告什么的或许可以用到。</p><h2 id="Vite、Taiwind-CSS、Next-js"><a href="#Vite、Taiwind-CSS、Next-js" class="headerlink" title="Vite、Taiwind CSS、Next.js"></a>Vite、Taiwind CSS、Next.js</h2><p>三个项目我就一起说了，因为其实都是典型的前端常用工具。</p><p>Vite是新一代的构建工具，用了<code>script</code> 标签类型的 <code>module</code> 作为主要引入方式，很新也很快，对于我而言我还是希望react配合vite的方案能够更成熟些才会考虑在实际项目中使用。</p><p>Taiwind CSS那么火我是没有料到的，我个人不是很喜欢这种方式去写css，也许是我的问题吧。</p><p>Next.js我没用过，nuxt倒是用过，服务端渲染其实更多的应该用于商业网站，但国内现在都是移动端优先，还拼命做私域，其实很难。</p><h1 id="2021我使用频率最高的开源项目"><a href="#2021我使用频率最高的开源项目" class="headerlink" title="2021我使用频率最高的开源项目"></a>2021我使用频率最高的开源项目</h1><p>这一年其实我围绕两大主题做了很多探索和研究，它们分别是信息流的聚合和自动化薅羊毛。</p><p>其实对于我的新闻阅读、讯息阅读是有个发展历程的，从一开始一个平台一个平台、一个博客一个博客的手动点到订阅RSS再到最终类似聊天式的信息对话，我也总算完成了我对信息流的改造，而最终的好处就是我可以非常高效率的获取每日最新的咨询（甚至可以说是第一时间），当然坏处是整个看完其实还挺花费个人时间的。</p><p>自动化薅羊毛是敏感词，我不是研究者而是使用者，所以只介绍平台，具体怎么实现就各凭本事吧。</p><h2 id="RSSHub"><a href="#RSSHub" class="headerlink" title="RSSHub"></a><a href="https://github.com/DIYgod/RSSHub" target="_blank" rel="noopener">RSSHub</a></h2><p>伟大的项目，解决了很多网站没有rss的情况，不必再自己重复造轮子。</p><h2 id="flowerss-bot"><a href="#flowerss-bot" class="headerlink" title="flowerss-bot"></a><a href="https://github.com/indes/flowerss-bot" target="_blank" rel="noopener">flowerss-bot</a></h2><p>基于TG的rss机器人，是我RSS机器人的第二讯息源。</p><p>顺便推广一下这个频道，它是userID是：@antsrss</p><h2 id="rssbot"><a href="#rssbot" class="headerlink" title="rssbot"></a><a href="https://github.com/iovxw/rssbot" target="_blank" rel="noopener">rssbot</a></h2><p>这是我的主力RSS机器人，上一个其实主要是订阅博客类的，这个才是我主要获取新闻咨询的机器人。</p><h2 id="qinglong"><a href="#qinglong" class="headerlink" title="qinglong"></a><a href="https://github.com/whyour/qinglong" target="_blank" rel="noopener">qinglong</a></h2><p>一个定时任务管理面板，可以拿来跑各种脚本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对egg.js框架的学习与理解</title>
      <link href="/2021/05/14/%E5%AF%B9egg-js%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2021/05/14/%E5%AF%B9egg-js%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>世界上几乎所有问题都可以用是什么，为什么，怎么办来解释，于是——</p><h1 id="为什么前端同学要涉及后端"><a href="#为什么前端同学要涉及后端" class="headerlink" title="为什么前端同学要涉及后端"></a>为什么前端同学要涉及后端</h1><p>因为前端领域的不断完善以及工程化，我们在开发前端页面过程中很多的开发工具、开发框架已经涉及到后端部分，只是可能当时并不知道，基于这个原因，开始涉及后端也是个必然的趋势了</p><h1 id="为什么选择-nodejs"><a href="#为什么选择-nodejs" class="headerlink" title="为什么选择 nodejs"></a>为什么选择 nodejs</h1><p>一大原因是作为前端人员我们对 javascript 已经非常熟悉，当我们再去涉及后端时，至少语法层面学习成本会降低很多。其次，nodejs 也有它自身的好处，包括它单线程处理机制，避免了出现线程同步、线程锁等问题，它的非阻塞 I/O，它的跨平台能力。</p><h1 id="egg-是什么"><a href="#egg-是什么" class="headerlink" title="egg 是什么"></a>egg 是什么</h1><p>egg 是阿里开源的一款 nodejs 后端框架，经过多年的沉淀，我个人觉得不像是一个 KPI 产品，而是一个可以真正值得适合企业级运用的后端框架</p><h1 id="为什么是-egg"><a href="#为什么是-egg" class="headerlink" title="为什么是 egg"></a>为什么是 egg</h1><p>首先，相比于个人或社区自发维护的框架，有阿里的加持可以保证至少还是有开发者维护的，尤其是假如阿里内部也在大量运用的话，长期维护是选择开源框架的一大要素</p><p>其次，egg 的文档足够完善和友好，虽然给的示范代码并不多，但各大功能说的非常详细和规范，这可以让我们在后续的开发中少走很多弯路</p><p>最后，egg 本身支持 typescript 且强调约定优于配置，基于这两点，我认为它非常适合中小团队开发，不需要在约定方面做太多工作</p><h1 id="egg-有什么"><a href="#egg-有什么" class="headerlink" title="egg 有什么"></a>egg 有什么</h1><ol><li>中间件服务</li><li>定时器功能</li><li>丰富的框架扩展</li><li>完备的日志功能，包括定时器日志、错误日志、主次进程日志等</li><li>基于 Cluster 模块实现多进程运行、通讯</li><li>针对 web 端常见的安全风险内置了丰富的解决方案</li><li>内置统一的异常处理方案</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>折腾一个好看的windows终端</title>
      <link href="/2021/04/16/%E6%8A%80%E5%B7%A7-%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84windows%E7%BB%88%E7%AB%AF/"/>
      <url>/2021/04/16/%E6%8A%80%E5%B7%A7-%E6%8A%98%E8%85%BE%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84windows%E7%BB%88%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读前介绍"><a href="#阅读前介绍" class="headerlink" title="阅读前介绍"></a>阅读前介绍</h1><p>为了更好的阅读，对以后的文章进行多平台同步并且统一采用markdown语法的方式。</p><p>当前文章支持阅览的地址有：</p><ol><li>微信公众号</li><li><a href="https://blog.hankqin.com/2021/04/16/折腾一个好看的windows终端">https://blog.hankqin.com/2021/04/16/折腾一个好看的windows终端</a></li><li><a href="https://telegra.ph/折腾一个好看的windows终端" target="_blank" rel="noopener">https://telegra.ph/折腾一个好看的windows终端</a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote><p>任何文章的初衷都可以用是什么、为什么、怎么办来解释。</p></blockquote><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2>前几天逛v2ex的时候碰到一个说关于有什么好的命令行工具的帖子，于是进去阅读，没想阅读完去搜索，居然还挺好看，于是本着我不折腾谁折腾的精神，我开启了我漫长的定制之路。</li></ol><p>至于命令行工具是什么我并不能解释清楚，但假如你是一位程序员你一定知道我在表达什么。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>我的第一代命令行工具使用的是<code>git bash</code>，它挺不错，但是也并非完美，我在使用过程中就遇到过乱码、无法打开很多个窗口等问题，而且它长得还非常中规中矩，让人喜欢不起来。</p><p>接着我又使用了<code>cmder</code>，它解决了多窗口的问题，也多了很多功能和样式，可以说还算是一个好工具。但依旧长得中规中矩。</p><p>于是我就在想，是不是有一款可以即强大又可以足够美观的工具。</p><p>于是就有了我的这一次折腾。</p><h2 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h2><h3 id="折腾的前提"><a href="#折腾的前提" class="headerlink" title="折腾的前提"></a>折腾的前提</h3><p>你需要有足够的耐心，非常足够的耐心，你可能会中途遇到很多莫名其妙的问题，你可能会因为一个问题引发另一个问题，最后要一路解决完才能继续教程的下一步，这都是非常正常的，这也是为什么说需要有足够的耐心。</p><p>当然，为了这样一个工具是否值得花费自己那么大精力和时间也需要自己去衡量。</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><ol><li>在Microsoft Store商店里搜索下载<code>Windows Terminal</code></li><li>下载完成后打开它，你将看到一个非常中规中矩的命令行界面</li><li><p>安装<code>posh-git</code>和<code>oh-my-posh</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装方式：</span></span><br><span class="line">posh-git： Install-Module posh-git -Scope CurrentUser </span><br><span class="line">oh-my-posh：Install-Module oh-my-posh -Scope CurrentUser</span><br><span class="line">注：有可能遇到不允许安装脚本，可输入set-executionpolicy remotesigned解决</span><br></pre></td></tr></table></figure></li><li><p>创建或更改$PROFILE配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果之前没有配置文件，就新建一个 PowerShell 配置文件</span></span><br><span class="line"><span class="keyword">if</span> (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;</span><br><span class="line"><span class="comment">// 用记事本打开配置文件，也可以用vscode打开：code $PROFILE</span></span><br><span class="line">notepad $PROFILE</span><br></pre></td></tr></table></figure></li><li><p>对$PROFILE配置新增数据</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module posh-git </span><br><span class="line">Import-Module oh-my-posh </span><br><span class="line"><span class="built_in">Set</span>-Theme spaceship</span><br></pre></td></tr></table></figure></li><li><p>下载字体</p><blockquote><p>前往<a href="https://www.nerdfonts.com/font-downloads" target="_blank" rel="noopener">nerdfonts</a>下载<strong>Caskaydia Cove Nerd Font</strong>字体，打开后可以看到后缀为ttf的字体，点击安装</p></blockquote></li><li>设置字体<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  打开Windows Terminal</span><br><span class="line"><span class="number">2</span>.  点击下箭头，选择设置</span><br><span class="line"><span class="number">3</span>.  选择打开JSON文件</span><br><span class="line"><span class="number">4</span>.  找到profiles =&gt; list</span><br><span class="line"><span class="number">5</span>.  在第一个数组对象里添加字段："fontFace": "CaskaydiaCove NF"</span><br><span class="line"><span class="number">6</span>.  保存</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本完成"><a href="#基本完成" class="headerlink" title="基本完成"></a>基本完成</h3><p>自此整个工具就安装完成了，但是要达到美化还有一步，就是设置背景和样式。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于最近对VPS的研究</title>
      <link href="/2020/06/09/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E5%AF%B9VPS%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2020/06/09/%E5%85%B3%E4%BA%8E%E6%9C%80%E8%BF%91%E5%AF%B9VPS%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>​    最近断断续续的一直在关注vps主机，虽然机子配置大同小异，但是因为线路的好坏价格总是天差地别，可能也因为这点，让我有一直想测试线路的冲动吧。</p><p>​    但是久了发现这玩意儿也确实比较耗时间，而且意义不大，要说科学上网，交给专业机场它不更好更稳定吗，要说挂网站，那也没有国内访问快啊，当然国内要备案这个没跑，但是如果你真是想拿来做些不正当的网站国外的vps也不允许不是。</p><p>​    不过经过这几个星期的关注，我算是有那么一些心得体会了，我确实有这个需求在，但是我也要理解市场，以我这个财力基本只够得着很入门的vps，但如果我又想获得极高的体验，那几乎是不可能的，所以首先要做的应该是放宽心态，别想着花那几个钱能拥有多高的体验，接着是得学会控制欲望，别一看这个便宜打折就买买买，结果不到两天全吃灰，下面经过我一晚上的思考，我把我的实际需求理了出来：</p><ol><li>需要一个国外VPS作为备用科学上网节点（可能还会套个CDN，防止可能发生非常严重的打击而所有节点无法访问）</li><li>需要一个延迟较低的VPS作为日常挂网站等各类服务（国内外都可）</li><li>需要一个好机场来满足我对外网速度和稳定性的要求</li></ol><p>​    大致需求就是这样，说说目前我有哪些VPS，一个阿里云的轻量学生机，google cloud首年免费的GCP，80块的racknerd欧洲VPS，目前我基本是在阿里云存放我的各类服务，别的均只拿来装了trojan。</p><p>​    根据刚才理出来的需求，可能需要稍微做一些调整。</p><p>​    所以就写到这吧，等我真的把我的需求弄得满意了或许会再开篇文章来说明清楚。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次RSS整合感想</title>
      <link href="/2020/06/03/%E8%AE%B0%E4%B8%80%E6%AC%A1RSS%E6%95%B4%E5%90%88%E6%84%9F%E6%83%B3/"/>
      <url>/2020/06/03/%E8%AE%B0%E4%B8%80%E6%AC%A1RSS%E6%95%B4%E5%90%88%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>​    经过一段时间的体验，实在受不了一个一个网站去点开，昨天对自己关注的一些博客网站进行了一轮”大规模“的整理订阅，有问题也有好处，所以就统一写写，给后面要整合的人一个参考。</p><p>​    RSS整合的好处自然不必多言，最明显的就是可以全部一下子看到，并且立马知道谁更新了，谁没更新，好在现在的博客大都使用框架，而框架基本都是大佬写的，所以基本都有支持RSS，基本一找一个准，但是也有特例，有两个网站也有，但是不知道为什么返回的并不是xml的格式，而是字符串，然后RSS阅读器解析不出来，针对这个问题后期我应该会自己爬取。</p><p>​    这里我想着重讲一下部分非博客类的，这部分反爬机制很严格，这就意味着需要经常维护，像这种明显要花费大量时间精力我肯定是不干的，所以我的折中方案是非博客类使用别的平台阅读，博客类使用RSS阅读器阅读，当然平台类还有一个问题是必须遵守国家相关法律法规，所以像”编程随想“这种基本不可能出现在平台上。</p><p>于是我的日常阅读就变成了阅读平台+RSS阅读器，实际体验下来就是只要你平日不是太忙，也挺方便。</p><p>至于后续爬虫是写在自己的服务器还是贡献代码给RSSHUB后面再说了。</p><p>最后说下用的平台和阅读器：</p><p>阅读平台：<a href="https://tophub.today/" target="_blank" rel="noopener">今日热榜</a></p><p>阅读器：<a href="https://www.inoreader.com/dashboard" target="_blank" rel="noopener">inoreader</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换了一个新主题</title>
      <link href="/2020/05/24/%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E4%B8%BB%E9%A2%98/"/>
      <url>/2020/05/24/%E6%8D%A2%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>​    许久没再更新我的博客，其实说不上忙，甚至还有些闲，但是慢慢的感觉但凡需要自己消耗脑力的东西总是习惯性拖延直至遗忘，大概这就是我这个阶段需要面临的挑战吧。</p><p>​    希望往下的日子，能以此为一个新篇章，更为积极的做一些事情，如果说我在24岁以前写过太多太多字，以至于直到今天都对写长篇的东西感到厌恶，那这个厌恶感持续了那么久也应该被渐渐抹去，在2020年的5月24日以后，好好的去记录一些关于自己的思考也好，想法也好，技术也好，反正好好的去记录自己想说的一切，不仅仅是为了留下些什么，更多的应该是一种心态，平和又努力的心态，不让这一天天可能枯燥、百无聊赖的生活磨平了自己的边角，从此随遇而安，任由生活将自己摆布。</p><p>​    加油吧，这有些难过的2020.</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嗨，W君</title>
      <link href="/2019/01/17/%E5%97%A8%EF%BC%8CW%E5%90%9B/"/>
      <url>/2019/01/17/%E5%97%A8%EF%BC%8CW%E5%90%9B/</url>
      
        <content type="html"><![CDATA[<p>这是一部小说。很多年以前写的。放于此备份，以免在日后丢失。</p><h1 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h1><blockquote><p>认识W君已不是一两天的事了，但真正想用文字记录却是最近的事。</p><p>W君是个姑娘，我私下喜欢叫她W君，这是个特别的名字，所以估计这世界上只有我才会用这个外号称呼她。笔下的W君一定有原形，但一定不会真真实实表达出来，而我之所以希望通过改编记下这些故事是因为我开始害怕，害怕要是老了或者一场意外让我失忆了，我将不再记得这些事，但我并不愿这样心甘情愿的忘记。就这样，我开始书写这些故事。</p></blockquote><p>   这是个歌舞升平的年代，当人们正急匆匆的从一个地方走到另一个地方的时候，十五岁的我却趴在窗口聆听着知了永不停息的唠叨。大人们说十五岁这个年纪很特别，你以为他们懂得了什么是爱，实际上他们只知道什么是做爱，对于爱，他们就是个大傻逼，一问三不知。</p><p>   但十五岁的我显然不象大人们说的那样不懂爱，十五岁的我既知道什么是做爱，也知道什么是爱。这完全归功于电视里放的电视剧，它们把爱和做爱解释得如此详细，我就算不想知道也注定是不行的，因为十五岁的我再看不进少儿频道的天线宝宝，只能选择这样一种电视风格。</p><p>   在我十五岁这样的年纪里，有好多好多故事可以诉说，但在所有故事里，显然遇见W君这个故事最耀眼又最深刻。所以在那个流行写日记但不流行写有故事的日记的年代里，我记下了和W君在十五岁这个美好岁月里发生的故事，而日记的开篇，便是《嗨，W君》。</p><h3 id="初遇W君"><a href="#初遇W君" class="headerlink" title="初遇W君"></a>初遇W君</h3><p>   八月确实是个开学的好月份，天气不冷不热，阳光又异常暖和，我最后从家里的窗户看一眼街道里匆忙的路人，便独自上学去了。就如所有学校的开学一样，我的学校里充满了繁忙的气息，升上初中二年级的我如今再看那些忙碌的爸爸妈妈和那些一脸茫然的学弟学妹，居然涌现一种莫名的伤感情怀，好像是感慨时光飞逝，又好像是伤心自己再没了那份激情，但没等我伤感完毕，W君就以一种极其电视剧的方式出场了，是的，就在教学楼的拐角处，她飞驰的步伐撞上了我悠闲的身体，于是她倒在了地上，我傻傻的站着，本来按照电视剧情，她应该一边说对不起一般低头捡自己的书，而我应该说你没事吧然后也低头帮她捡书，但那显然是电视剧，真实的故事是W君被撞倒后，就生闷气的坐在了地上，脸上摆满了无奈又生气的表情，而我则原地不动，眼都不眨的看着她，就这样各自维持了几分钟，直到老师偶然经过发现了这个意外，大家才回过神捡书道歉离开。</p><p>   之后我的班主任便在开学第一堂课介绍新来的同学，之后W君出场，之后我们就成了同桌。我一直无法理解班里那么多空座位，为什么班主任却偏挑了我这个空位让W君坐，这直接宣布了我往后独处生涯到此结束。这就是W君的出场，在那一天放学，我悲从中来，给W君写了一张纸条——认识你真他妈的高兴。</p><h3 id="关于W君"><a href="#关于W君" class="headerlink" title="关于W君"></a>关于W君</h3><p>   关于W君此人，如果限用一个字说出她的性格，那我会选择“怪”这个字，这并不是说W君相貌奇特或哪个身体部位奇怪变异，W君有一副好脸蛋和好身材，但性格却是非常奇特，以至于有时候我怀疑她被派来地球是另有目的。有时候你以为她抱着本数学练习来找你是想要你帮解答解答，不，她只是想和你聊聊天；有时候她笑哈哈的向你走过来，你以为一定有什么开心的事要说，不，她只是有道题目不会，过来请教你。虽然不可否认，W君这家伙笑起来的样子十分好看，整齐洁白的牙齿常亮瞎我呆滞的双眼，但假若你相信了她的笑容，那你便入了她的紧箍咒，在经受了无数陷阱的折磨后，你才会不再相信她的笑容，甚至宁愿她哭她怒她悲伤或者宁愿她嘟嘴装非主流，也不愿她笑。但事实上她每天都在笑，每天都这样灿烂，而我身为她的同桌，除了无数次想强奸她的冲动外，已慢慢起了杀心，我知道这一天已经不远了，只要她再多笑几天。记得世界上有句真理是这样说的——有些人活着，她就想让别人死，有些人死了，她也不让别人活着。</p><p>   这就是我对W君的介绍，她本人当然不同意，但在我的小说里，显然反对无效，我心里W君就是如此，不容更改。</p><h3 id="对话W君"><a href="#对话W君" class="headerlink" title="对话W君"></a>对话W君</h3><p>   那一天放学把纸条送给W君后，十五岁的我带着十五岁的心情快步的回到了家，这并不是我对W君有了怎样的内心感情，而是5点准时播放的《天龙八部》马上就要到了。在那个故事和电脑都没有泛滥到心里的年纪，显然一部高端的电视剧便是最为重要的娱乐品。当然，就算说那么多的题外话也是逃不过第二天要上学的命运的。</p><p>   第二天早上刚到教室一坐下，身旁的W君便深情的望着我，而我之所以知道她是深情地望着我是因为当时我压根没注意身旁有个人，而是一直在考虑段誉在学了凌波微步后会有什么伟大举动，是W君自己看得不耐烦才“喂”的一声叫我，然后告诉我她深情地望了我这么久我却一眼都没看过来，具体过程是这样的：</p><p>   “喂”W君说</p><p>   如果不是距离太近，我压根不会觉得“喂”这样称呼有一天会是用来叫我的。听到W君的呼喊，我悠悠回过头，一副段誉遇到语嫣的表情，等待她的一句。</p><p>   “我这样深情地望了你这么久，你难道不应该看过来一眼吗？”W君一副天真单纯的样子（一年多后我才发现那不过是魔鬼的伪装，专门欺骗那些没见过世面的灵魂罢了。）</p><p>   而对于这样无内涵的问题，一心耍帅的我自然是不会回答的，只管望着她，听她的下一句。</p><p>   “对于我一不小心成为你同桌这件事，你好像很有意见，是吗”这下W君一针见血，句句问得恰到好处。</p><p>   而我听到这个问题，心中立马浮现一个忧郁男子在某个阴暗角落埋头吸烟的场景，看样子好像是不愿她离开，口中还隐约说着不是，但事实上我口中说的却是“没错”，是的，我盯着W君，假装很坚定的告诉她：“没错！很有意见。”</p><p>   之前在“关于W君”里我已经提到，W君是个性格极其怪异的人，所以我本以为她会同班主任申请换座位，，却没想到她只是快乐的露出她那雪白的牙齿，笑着告诉我：“哦，那可不关我的事啊！”</p><p>   在那一刻，我心中万马奔腾，内心极度渴望化身乔峰，先来招降龙十八掌，再连上全套打狗棒法，最后一个擒龙功将她碎尸万段。</p><p>   幸运的是，上课铃声在此刻突然想起，老师走了进来。如果没有这个小插曲，小说必然得改成《纪念曾经的W君》这样悲伤的名字。</p><p>   虽然上课时间不同W君讲话，没料到她却一直对我笑，一种极其暧昧的笑（是的，十五岁的我知道暧昧这个伟大的词）。当一个女生总喜欢对一个男生暧昧的笑的时候，男女必定开始有了一些微妙的变化，最常见的是男生和女生好上了，但还有一种是男生要倒大霉了，显然，我的是后者。</p><h3 id="战无不胜的W君"><a href="#战无不胜的W君" class="headerlink" title="战无不胜的W君"></a>战无不胜的W君</h3><p>   在历史的长河里，虽则与W君发生了许许多多的故事，但次数最多的应该是同她的争吵。我与W君的争吵如今想起来是颇有意思的，虽没有政客般争得面红耳赤，却也绝不会同夫妻那样床头吵完床尾和，既不属男女朋友那样凭感性争吵，又不像学者般总拿例证说话。</p><p>   然而，不知道是我天生不善辩还是心中胆怯，每次争论必是我输，无一例外。有时俩人争到最后，发现作业都没完成，她便比我先开始着急，这才勉强承认我胜利，我自己当然不服气，却也不敢同她动手，只能臭臭脸，也埋头写自己的作业去了。细想我之所以不敢同她动手的原因，一是因为她是个留有辫子的姑娘，二是我不一定能打得赢她，这绝非是小说剧情需要才胡乱瞎说，十五岁的我在那个时候确实尚未发育完全，而W君在那时已有了几分姿色，假若对上，在力量上是绝占不了便宜的。事实上，也是基于这个原因，W君如今才仍能在遥远的北方过着快乐的生活而未被我杀害。</p><p>   那是一个闲暇的午后，刚从午觉中醒来的我拖拉的走进教室，坐到座位，无意侧眼一瞟，W君那蒙娜丽莎式笑容正不偏不倚的对着我，看她那饱含深情的双眼，那红润的樱桃小嘴，连那轻轻的呼吸都那般动人，倘若那一刻被哪个摄影大师拍下，绝对能成为一副温馨浪漫的艺术作品。但，那不过是世人世俗眼睛的主观判断罢了，对于身处现场的我而言，红色预警早已以一种近似慌张的形式在脑中响起，一时间，什么觉后的睡意，什么上课的内容，全都归于空白，心里只念着不要，不要这样呼救的词。但，灾难从来没有想过会因为谁的祈祷而放慢脚步，W君终于还是开口了。</p><p>“诶，听说过三毛的死吗？”</p><p>“恩”</p><p>“你觉得会出于什么样的原因呢？”</p><p>“不知啊”</p><p>“那有读过三毛的书吗？”</p><p>“恩”</p><p>“觉得是个怎样的人呢？”</p><p>“不清楚啊”</p><p>   从上面几句简短的对话里，我走得异常小心，在这种时候，已完全属于交战阶段，假若我太着急，最后一定会弹火用尽，再无反抗之余地。</p><p>“我觉得她有抑郁症，不然不至于在出国前的几年不愿说一句话。”</p><p>“不过你猜测罢了”</p><p>“那她何至于不愿对人多说几句呢，又不是没有要好的朋友。”</p><p>“不愿多说就是抑郁？”</p><p>“那自然不是。可连她父母都这样地认为。”</p><p>“若你父母现在认为你是个男孩，你会马上去剪个平头吗？”</p><p>“亏你和我同桌这样久，倒是一点没嗅到我艺术家的气息哦！”</p><p>“总之不会是抑郁症，不管你怎么说。”</p><p>“又不敢说原因。知道你想同我反抗，但没有观点劝你还是不要逞强好。”</p><p>“我说W君，掐指一算，我们辩论不下十回了，激将法这招你都用了七八回了，我的冲动早被你磨完了。”</p><p>“你就全当我没有观点好了。</p><p>”呵呵，那倒也是。每次辩论都是我胜，也怪不好意思的。“</p><p>“哼，又没有评委，怎么说每次都是你赢，讲不定你没一次赢。”</p><p>“那倒不是没有可能，可别忘了，每次说到语塞的总是你哦，呵呵呵呵~”</p><p>   终于出来了，W君那必杀的绝招终于使出看那雪白的牙齿，那眯成缝的眼睛，那两个小小的酒窝，听那爽朗的笑声，迷住世间任何一个异性都不会有问题。</p><p>   这一下，我默默的低下头，我意识到导弹快要发射，灾难马上上演。</p><p>”首先，她本来就曾经说过，她那不是抑郁，只是一种莫名的害怕。其次，倘若抑郁，在巴西，在撒哈拉，她又怎么认识那一群群的朋友，怎么会在离身回国后叫他人如此思念。最后，生活有很多意外，所以你可以说三毛最后是自己拔掉输液管自己，但我也可以认为只是一个意外，终究是解不开的东西。“</p><p>   一口气，我把所有理论说了出来，这一下，可算是正式的接受了她的挑战。</p><p>”原来你还是有些观点的吖，哈哈~“</p><p>   我双唇紧闭，待她接下来的还击。</p><p>”你可知道，三毛为了写作，为了赶在截稿时间之前，把自己憋在屋里不出门，吃饭都让人从门里送进来，有时过了很久第二天去时昨天的饭菜还在，她把自己弄得太累了，写完作品就立即进了医院。“</p><p>”我不知”</p><p>“那你又知不知三毛最后是自缢而死的?”</p><p>“不知“</p><p>“所以我会觉得对于一定的文人，是会有那么一些抑郁的，像海明威，像三毛”</p><p>铃铃铃…</p><p>“这节课上到这，下课”不远处传来老师的声音 ，但在我的脑海里，老师似乎是说着”本场辩论结束“，无疑，这样一场辩论我又以无言以对收场。这样的结局让我回忆起上次那场谈论异地恋，上上次谈论手机的结尾，都全像约好了似的让我颇为难堪。</p><p>”啊，下课啦，哈哈~“这是W君特有的一种宣告胜利的方式，最标志的是那笑容，在这里我已不愿再次描述，在这样悲伤的环境下仍然开怀大笑的人，是不被我原谅的，所以在这场谈论后，我自家心里对她的仇恨又加了一笔，仔细一算，心中的仇恨已经可以写成个”衅“字了。</p><p>   这次的争吵大抵就是这样，当然之后的日子又不明不白的争吵了无数次，心中的仇恨已可以写成一封血书。</p><h3 id="十五岁的那场告白"><a href="#十五岁的那场告白" class="headerlink" title="十五岁的那场告白"></a>十五岁的那场告白</h3><p>​    算是一个小插曲了。这是那个学期末，在日记本里做为一个学期日记的压轴篇。不管怎么说，在一起同桌这样久俩人都没有伤亡，真是不易，多少要写些什么以表纪念：</p><p>   W君，算下来一个学期又完了，你在这学期的最后一天还是把我吵赢了。恭喜。</p><p>   W君，其实你是个挺可爱挺温柔挺漂亮的姑娘，只是我没有看出来罢了。原谅我在认识你一个月后每次见你笑自己都会脸红，这一定让你误会我喜欢你了，其实不是的，我只是在你每次笑时觉得异常紧张 ，随着内心红色警报的响起，激素迅速分泌而导致的脸红。</p><p>   你瞧，天气也快寒冷起来， 当初看你短裤短T恤时内心的小九九也因为这气温进入冬眠状态，转眼我这十五岁又快过去了，算是又老了一岁吧，其实没过三十说老我自己是觉得有些不妥的，但我之所以一次又一次容忍你在我面前说”又老了“这些话是因为你总是在我写作业时说，我自然也就懒得理你，唯独一次，我闲得慌，听你又唠叨起来，便轻敲了你脑袋一下，不料你却同班主任告状，害我写了一千多字的检讨。这不怪你，真的，只怪我自己没有把你杀害。</p><p>   有一段时间，我是十分喜欢你的。那段时间你不知受 了什么打击，话变得极少，也不再同我争吵，我心里欢乐得不行，记得好几次都高兴得把你抱在怀里。那段时间里我真正放心去看你那迷人的笑容，发现它实在美妙极了，有种以前从不曾发现的美丽。不过几日，我便被你迷住了，当下决定写情书跟你表白，前后约莫一个星期的日子，我本打算在那天提前放学后把情书交给你，万万没想到，你竟又找我辩论起来，我当时气得不行，才一连盯着你好久，要不是你一打铃就冲出教室，真不知道我会做出什么样的事来。</p><p>   W君，其实故事这东西，有时候是大可不必需要结局的，你也不要对我不小心把那本小说的结局弄丢太耿耿于怀了，有时候结局总是不如你想的精彩，还是留点空间自己遐想的好。</p><p>   还有，回家的那条路又通了，如果还想跑来看电影，提前同我说一声，我好问问家里有没有电，不然又可能要度过一个无趣的周末了。</p><h3 id="W君的哭泣"><a href="#W君的哭泣" class="headerlink" title="W君的哭泣"></a>W君的哭泣</h3><p>​    倘若说人总是具有两面性，那W君悲伤的一面是极难遇见的。或许于别人而言，W君确算个非常乐观的姑娘，总是成日笑嘻嘻，时不时搞些古怪捉弄别人，平日里绝不会看到有丝毫悲伤的样子。但世间又有谁说自己是真心实意的永久保持着快乐的呢，那伪装极深的欢乐，我们又如何读得明白。如今我身旁的W君，亦非圣人也并不是行尸走肉，虽不敢胡言她那灿烂的笑容是伪装出来的，但她那真正悲伤时的样子确是这样千真万确的。虽说W君只是个邻家小姑娘，但内心确是十足的坚强，这是无论同我辩论亦或同我谈天再或同我做题时都有表现出来的，W君的坚强是一种气息，噢不，或许比作一种香水气味要更恰当，每次出门前，她便把这坚强的香水喷洒往自己身上，然后仔细拍打涂抹，倘若不小心触到某个未愈合的伤口，也坚决的咬紧双唇闭紧眼睛，任由疼痛侵袭全身。待疼痛过去，香气抹匀，再昂首挺胸从门口走出，迎接一天全新的日子。可W君不曾想到的是，坚强即使能激励自己，骗过别人，却始终穿不透自己的内心，香不进自己的背影。<br>   我再某个十二月最冷的日子里第一次撞见W君的落寞，但凡读过中学的朋友都晓得，中学下午放学的时间约莫是5点时辰，放学后除下刻勤奋的同学，大多都跑去运动或回家，即使那些仍在教室勤学苦读的同学也绝不会多呆到6点这样的时辰，我和W君自以为都是平凡一生的庸人，所以每至放学铃响，必是最先离开的，在这一场比赛谁第一个离开教室的斗争里，我依旧因W君的诡计多端而从未战胜过她。<br>​    但就在那十二月最冷的一天里，我一切准备就绪，即将飞箭一样要跑出教室的时候，W君却仍坐在自己的座位，丝毫没有要动的样子，而我因为昨日又被她吵得哑口无言正生着闷气，索性也不去理会她，以第一名的绝对优势跑出门口，离开了教室。当我正洋洋得意的走在回家路上，想着《天龙八部》里精彩的剧情，习惯性手摸一摸口袋，糟糕，开门的钥匙还被我留在抽屉，平日都是W君告诉我并以此战胜我，今日她却不同自己比了，钥匙便无人提示，这下可真是无奈极了，父母这个时候也是绝不会回来的，打119又感觉对不住那忙碌的警察叔叔，终于只有再跑回去拿这一条路可以走了。想到今晚的《天龙八部》因此泡汤，心中所有的喜悦都烟消云散，只留有一片乌云陪我走回到教室。<br>   我快步来到教室门口，刚要闯进，忽见W君坐在窗边，戴着耳机呆呆的望着天空，就是这一刻我看到了她那悲伤的面容，平日红润的双唇如今变得苍白，眼神里的那股灵动也换成无比幽深的空洞，随时撞见的小酒窝也不复存在，只留下两道泪水滴过的痕迹，已到肩的发向两边散开，将耳朵藏在黑暗中，仅剩的一点夕阳把她的背影拖得很长，像极了那消瘦的老人。看到这样的一幕，本已心情郁闷的我更为难受，实在有一种冲过去一把抱住她，同她一起在夕阳落下的时刻里抱头痛哭的冲动。但一想起此次的目的不过是拿钥匙赶回家，心中的冲动便又退去，只在她整齐的桌面留下一张纸条，便抓起钥匙再次赶回家中。<br>   第二天上学，W君问我知不知道这张只画有笑脸的纸条是谁放的，为了保证它的神秘感且不暴露昨天看到的那一幕，我除了坚决说不知，还调侃的说：“大约是哪个男生喜欢上你了罢。”W君听完这话，竟真把纸条好好收藏在包中，自己偷乐了一整天，我见她又变得这样开心，慢慢地对昨天的那一幕也失去了记忆，望着她欢快的笑容，竟主动找她辩论了起来。 </p><p>黎明之前 </p><p>   当亲爱的太阳尚未从遥远的西方赶回来时，我所居住的城市一片沉寂，仿佛你站在任何角落，都能听得到远处的知了忧伤的鸣叫。城市流浪汉也好，疯狂的少男少女也好，此刻也都已经安静了下来，周围稀薄的空气不知不觉中凝成了冰水，滴落在城市的各个角落。<br>   黎明之前的这段长久的黑暗笼罩了我的居所，躺在床上的我潜意识里隐约在感受着某些特别的画面，我努力将它们定格，却总是忽然的一片漆黑。窗外诡异的风拍打着窗户，我渐渐意识到我的身体，我的眼睛，我整个肉体正置身于一片大草原，一片放眼望不到边的草原，我的灵魂正在我的前方以极快的速度奔跑，等它跑得只看到一个点时，我的心便开始莫名的疼痛起来，我想我得追上去，把它追上，带走。<br>   我决定追上去，脚在此时已不自觉的动了起来，竟没想到我自己也像我的灵魂那样奔得飞快。看着灵魂一点一点接近，一种极其剧烈的安全感笼罩了我，我渐渐放心了下来。纵然风依然不罢休的敲打窗户，黑暗依旧没有要离开的样子，此刻我已归属黎明，获得光明。<br>   正当我一阵喜悦，刚要抓住我的灵魂的时候，一切又忽然变得漆黑，大草原和灵魂以最快的速度消失在我的眼前，我空空的肉体发了愣，竟不知该用什么样的表情。<br>  因为这长久的黑暗， 慢慢的，我的身体开始 抽搐起来，先是左脚，后到右脚，接着是左手，又到右手，终于整个身体都抽搐了起来，我承受不住，倒在了地上。<br>   街道上可怜兮兮的树干被风吹得左右乱晃，流浪汉和少男少女们蜷着身躯安静的睡在马路边，太阳还在赶来的路上，夜已经黑到了它的极致，被落在某个不见光明的角落里的我仍在抽搐，黎明之前的这段时光，表现得异于往常的腐败。</p><h3 id="W君的离去"><a href="#W君的离去" class="headerlink" title="W君的离去"></a>W君的离去</h3><p>   不记得是哪个大人喝醉酒后曾对我说过——时间这东西啊，你得看着它，不然它什么时候跑掉你都不知道啊。我当时听起来十分可笑，时间不就是在这吗，它再怎么跑能有我跑得快？<br>   而我真正读懂这句话是到了初三最忙碌的时候听到W君离开的消息。<br>   那是个刚入季的却已明显升温的月份，平日的W君这种时候是非常单纯的，如果她要和你吵架，在这种时候是非常直接且非常快入题的，如果她要同你比赛，在这种时候也是非常豪爽洒脱的，但今年的这个时候，W君一直沉默不语，我默默的在心中庆祝了七天后，终于忍不住在某节课后以一种漫不经心的方式问她：<br>“我说，最近吃错什么药了？”<br>W君摇头，这是平日里绝见不到的表现。<br>“那是谁欺负你了？我帮你跟班主任打小报告。”<br>W君扭头白了我一眼，在这样极具讽刺的话语里她依旧保持沉默。<br>“难不成是考试临近，心情紧张？还是怕我考得比你好？”<br>如我所料，我又被她白了一眼，而这个时候我也偷偷感觉到自己的无趣，便也坐正姿式，低头写起作业来。也不知是多久，W君终于开口，她只说了四个字，听起来似乎极其忧伤——“我要走了”。<br>   在这种时候，按照剧情，我会惊讶，然后难过，然后同她来个过几个月就会忘的约定，然后慢慢陌生，终老。但显然没那么可爱的剧情，在W君开口后，我依旧在演算着一道题目，于是在这样伤感的情景下，我头也不抬的说：“哦，走吧，现在没空和你比赛，这次算你赢。”<br>   听完这话，W君立在那有30秒之久，我却始终无暇扭头看她一眼，或许那会儿她已泪流满面，或许依旧保持着她的微笑，总之三十秒后她便走了，第二天，第三天，第四天，……直到中考结束我都再没有同她见过，我以为我会存有她的某样联系方式，但翻遍屋子，终于没有发现。</p><h3 id="海的誓约"><a href="#海的誓约" class="headerlink" title="海的誓约"></a>海的誓约</h3><p>   中考完后，我的日记便没在继续。在即将结束日记的那一天，我忽然又莫名的想起了W君，想起她那再害不了我的笑容，想起同她去海边吹风的场景，便写下了这最后一篇日记——《海的誓约》：<br>   W君，你好。<br>   想不到同你最后的道别是这样简陋，你自己也不同我说清楚，让我总以为只是要我同你比赛。不过算了，总是要走的，只是你走得让我如此始料未及。<br>   在这最后的日记里，就不再数落你了，不管是如何的被你嘲笑啦，欺骗啦，打扰啦，都不究了罢。<br>   我只是想同你说说关于那次被你骗去海边后的心情和想法。<br>   那天被你骗去海边后，看着明媚的阳光和蔚蓝的大海，本想骂你一顿的念头不自觉就消失了。你说海给你安静的气息，让你忘掉许多不开心的事，你还说看那望不尽的大海能让给你想飞想自由，你说了好多好多，我都没有对此说些什么，这是你安静的一面，我很欣赏。<br>   在海风吹来，海浪滚滚的那刻，你小声的告诉了我你的梦想，我第一次认认真真的听了进去而没有嘲笑你，不管怎样，不论是谁，有个梦想总是不赖的，在这方面，你也确实有条件，所以希望真的有一天，我能在那个领域知道你，认识你。<br>   你说约好二十年后比比谁活得更好，我也没怪你无聊就答应下来了，但仔细一想，这估计真得需要常联系才能知道二十年后俩人各在什么地方啊，而我却早已没有方法联系你。<br>   所以还是再见吧W君，你也知道，谁都说不准命运这回事，虽然你不信。<br>   愿天常蓝，树常绿，你笑容依旧。<br>​                                                                                                                                                     —— 完<br>（最终还是写完了而不是半途而废，烂也好，水也罢，我已经勇敢的把它更新完了，不管怎么样，总算对得起自己，或许也对得起W君。往下的日子再没有那么多时间去写那么长的东西，也说不上可不可惜，毕竟还没到，我也不知道。<br>因为是只给W君的，所以写完了，就锁了吧，大伙看完便忘，谁也别去在意这些，只需尽情享受当下的生活就好。） </p>]]></content>
      
      
      <categories>
          
          <category> 备份 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>google搜索进阶</title>
      <link href="/2019/01/17/google%E6%90%9C%E7%B4%A2%E8%BF%9B%E9%98%B6/"/>
      <url>/2019/01/17/google%E6%90%9C%E7%B4%A2%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="精确搜索"><a href="#精确搜索" class="headerlink" title="精确搜索"></a>精确搜索</h1><h3 id="精确的关键词排列"><a href="#精确的关键词排列" class="headerlink" title="精确的关键词排列"></a>精确的关键词排列</h3><p>使用<code>“关键词”</code>，如果直接输入关键词，可能词与词之间会分隔很远，不符合你想要的搜索结果  </p><h3 id="限定搜索的网站"><a href="#限定搜索的网站" class="headerlink" title="限定搜索的网站"></a>限定搜索的网站</h3><p>如果你只是想搜索特定网站的关键词，可以使用<code>site:网站地址</code>限定</p><p>注意1：网站地址不需要加<code>http://</code>或<code>https://</code></p><p>注意2：网站地址也可以是泛式的，如<code>.com</code>则表示只搜索.com域名的网址</p><h3 id="只搜索网站标题"><a href="#只搜索网站标题" class="headerlink" title="只搜索网站标题"></a>只搜索网站标题</h3><p>如果你要查找的关键词只需要在网站标题中出现，可以使用<code>intitle:关键词</code>搜索</p><p>拓展：</p><p>1.多个关键词——<code>allintitle:关键词1 关键词2</code></p><p>2.一个模糊一个精确——<code>关键词1 intitle:关键词2</code></p><h3 id="只搜索网页正文"><a href="#只搜索网页正文" class="headerlink" title="只搜索网页正文"></a>只搜索网页正文</h3><p>使用方法同上，单词为<code>intext</code>和<code>allintext</code></p><h3 id="只搜索网站地址"><a href="#只搜索网站地址" class="headerlink" title="只搜索网站地址"></a>只搜索网站地址</h3><p>方法同上，单词为<code>inurl</code>和<code>allinurl</code></p><h3 id="只搜索指定格式"><a href="#只搜索指定格式" class="headerlink" title="只搜索指定格式"></a>只搜索指定格式</h3><p>方法<code>filetype:格式名称</code></p><p>可以只搜索你想搜的特定格式的地址，如你想找一本pdf格式的书，你就可以输入<code>书名 filetype:pdf</code></p><h1 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h1><h3 id="同义词（波浪号）"><a href="#同义词（波浪号）" class="headerlink" title="同义词（波浪号）"></a>同义词（波浪号）</h3><p>紧挨着关键词之前放波浪号 <code>~</code> 表示搜索同义词。<br>有了这个功能，你就不必用 <code>OR</code> 写一堆关键词。因为 Google 是足够聪明的，知道哪些词汇是近义词。</p><h3 id="数字范围（两点）"><a href="#数字范围（两点）" class="headerlink" title="数字范围（两点）"></a>数字范围（两点）</h3><p>两个数字之间放两个小数点 <code>..</code> 表示模糊搜索该数字范围。</p><p>如：<code>世界杯 2002..2010</code></p><h3 id="通配符（星号）"><a href="#通配符（星号）" class="headerlink" title="通配符（星号）"></a>通配符（星号）</h3><p>可以用<code>*</code>代替任何一个词汇。</p><p>如你要搜索一个叫“以飨读者”的成语，你不指定“飨”怎么写，就可以用<code>*</code>代替，在搜索框输入<code>&quot;以*读者&quot;</code>试试吧。</p><p>除此之后，还能与<code>site</code>配合使用，扩大搜索范围，如<code>关键词 site:sina.com.*</code></p><p>注：新浪有几个域名sina.com.cn、sina.com.hk、sina.com.tw</p><h1 id="排除某些关键词"><a href="#排除某些关键词" class="headerlink" title="排除某些关键词"></a>排除某些关键词</h1><p>使用<code>-关键词</code>即可排除你想要排除的关键词了，如<code>甲骨文 -数据库</code>即可排除关于oracle 数据库方面的信息了。</p><p>拓展：此方法可以配合<code>site</code>以及<code>filetype</code>使用</p><h1 id="其它搜索"><a href="#其它搜索" class="headerlink" title="其它搜索"></a>其它搜索</h1><h3 id="google当词典"><a href="#google当词典" class="headerlink" title="google当词典"></a>google当词典</h3><p>在你想要查询的词前加<code>define:</code>，输入<code>define:中文</code>试试吧</p><h3 id="google换算汇率"><a href="#google换算汇率" class="headerlink" title="google换算汇率"></a>google换算汇率</h3><p><code>100 USD to CNY</code></p>]]></content>
      
      
      <categories>
          
          <category> Google </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Airbnb的JS代码规范整理</title>
      <link href="/2019/01/11/Airbnb%E7%9A%84JS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
      <url>/2019/01/11/Airbnb%E7%9A%84JS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要重复写一些别人已经写好的东西？"><a href="#为什么要重复写一些别人已经写好的东西？" class="headerlink" title="为什么要重复写一些别人已经写好的东西？"></a>为什么要重复写一些别人已经写好的东西？</h2><p>1.每个团队都有一些自己的个性化的东西，不能完全照搬别个的。</p><p>2.整理的过程也是自己学习的一个过程，能让自己在无意识中规范自己的代码。</p><h2 id="正文开始"><a href="#正文开始" class="headerlink" title="正文开始"></a>正文开始</h2><h3 id="定义变量方面"><a href="#定义变量方面" class="headerlink" title="定义变量方面"></a>定义变量方面</h3><p>1.存取直接作用于它自身或它自身的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>2.通过直接量创建类型且应避免使用保留字</p><p>补充：定义变量时最好用名词，定义方法时最好用动词</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superman = &#123; <span class="comment">//避免使用new Object()</span></span><br><span class="line">    defaults: &#123; <span class="attr">clark</span>: <span class="string">'kent'</span> &#125;, <span class="comment">//避免使用default等保留字</span></span><br><span class="line">    private: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.拷贝数据时最好用深拷贝，保证与原数据无关联</p><p>补充：可使用lodash的cloneDeep或者自己写的<a href="https://github.com/Qinhank/h-toolbox" target="_blank" rel="noopener">h-toolbox</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cloneDeep &#125; <span class="keyword">from</span> <span class="string">'h-toolbox'</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> copyArr = cloneDeep(arr)</span><br><span class="line">copyArr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr,copyArr)</span><br></pre></td></tr></table></figure><p>4.不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.将未赋值的变量定义在最后面（可以引用前面的变量）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = getItems();</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> dragonball;</span><br><span class="line"><span class="keyword">var</span> length;</span><br><span class="line"><span class="keyword">var</span> i;</span><br></pre></td></tr></table></figure><h2 id="比较运算符-amp-等号"><a href="#比较运算符-amp-等号" class="headerlink" title="比较运算符 &amp; 等号"></a>比较运算符 &amp; 等号</h2><p>在实际开发中有个问题其实很不起眼但是又很容易出错，那就是做判断的时候，因为js的弱类型，很多判断如果不精准的话可能会造成一些错误。如需要判断变量a是否存在，可能会很自然的写a?true:false，但是这样一来当a为0时可能也会被判断成false。</p><p>所以正确的写比较写判断是非常有必要且非常值得重视的。</p><p>先列一下js中一些常用的类型通过<strong>ToBoolean</strong>会变成什么吧：</p><ul><li><strong>对象</strong> 被计算为 <strong>true</strong></li><li><strong>Undefined</strong> 被计算为 <strong>false</strong></li><li><strong>Null</strong> 被计算为 <strong>false</strong></li><li><strong>布尔值</strong> 被计算为 <strong>布尔的值</strong></li><li><strong>数字</strong> 如果是 <strong>+0、-0 或 NaN</strong> 被计算为 <strong>false</strong>，否则为 <strong>true</strong></li><li><strong>字符串</strong> 如果是空字符串 <code>&#39;&#39;</code> 被计算为 <strong>false</strong>，否则为 <strong>true</strong></li></ul><h3 id="优先使用-和-而不是-和"><a href="#优先使用-和-而不是-和" class="headerlink" title="优先使用 === 和 !== 而不是 == 和 !="></a>优先使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code></h3><h3 id="判断是否存在一个长度大于0的数组"><a href="#判断是否存在一个长度大于0的数组" class="headerlink" title="判断是否存在一个长度大于0的数组"></a>判断是否存在一个长度大于0的数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr &amp;&amp; arr.length) &#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>一般一个大型项目中，实际给每一个<strong>function</strong>做长注释是很累的，所以我更希望是这样一个原则：在业务中用单行注释简单说明，在公用函数中则必须把具体的信息全部做好注释。</p><h3 id="使用-作为多行注释。包含描述、指定所有参数和返回值的类型和值"><a href="#使用-作为多行注释。包含描述、指定所有参数和返回值的类型和值" class="headerlink" title="使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值"></a>使用 <code>/** ... */</code> 作为多行注释。包含描述、指定所有参数和返回值的类型和值</h3><h3 id="使用-作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行"><a href="#使用-作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行" class="headerlink" title="使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行"></a>使用 <code>//</code> 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行</h3><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="使用-2-个空格作为缩进（非常重要！！！非常重要！！！非常重要！！！）"><a href="#使用-2-个空格作为缩进（非常重要！！！非常重要！！！非常重要！！！）" class="headerlink" title="使用 2 个空格作为缩进（非常重要！！！非常重要！！！非常重要！！！）"></a>使用 2 个空格作为缩进（非常重要！！！非常重要！！！非常重要！！！）</h3><h3 id="在大括号前放一个空格"><a href="#在大括号前放一个空格" class="headerlink" title="在大括号前放一个空格"></a>在大括号前放一个空格</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>,&#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>, &#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用空格把运算符隔开"><a href="#使用空格把运算符隔开" class="headerlink" title="使用空格把运算符隔开"></a>使用空格把运算符隔开</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> x=y+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> x = y + <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h3 id="使用链式调用时要进行缩进。使用前面的点-强调这是方法调用而不是新语句"><a href="#使用链式调用时要进行缩进。使用前面的点-强调这是方法调用而不是新语句" class="headerlink" title="使用链式调用时要进行缩进。使用前面的点 . 强调这是方法调用而不是新语句"></a>使用链式调用时要进行缩进。使用前面的点 <code>.</code> 强调这是方法调用而不是新语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">$(<span class="string">'#items'</span>).</span><br><span class="line">  find(<span class="string">'.selected'</span>).</span><br><span class="line">    highlight().</span><br><span class="line">    end().</span><br><span class="line">  find(<span class="string">'.open'</span>).</span><br><span class="line">    updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">$(<span class="string">'#items'</span>)</span><br><span class="line">  .find(<span class="string">'.selected'</span>)</span><br><span class="line">    .highlight()</span><br><span class="line">    .end()</span><br><span class="line">  .find(<span class="string">'.open'</span>)</span><br><span class="line">    .updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).classed(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>, (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>)</span><br><span class="line">    .data(data)</span><br><span class="line">  .enter().append(<span class="string">'svg:svg'</span>)</span><br><span class="line">    .classed(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>, (radius + margin) * <span class="number">2</span>)</span><br><span class="line">  .append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br></pre></td></tr></table></figure><h3 id="在块末和新语句前插入空行"><a href="#在块末和新语句前插入空行" class="headerlink" title="在块末和新语句前插入空行"></a>在块末和新语句前插入空行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> baz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure><h2 id="持续更新中…"><a href="#持续更新中…" class="headerlink" title="持续更新中…"></a>持续更新中…</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记给Hankqin这个系统的一次升级</title>
      <link href="/2018/11/20/%E8%AE%B0%E7%BB%99Hankqin%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E6%AC%A1%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/11/20/%E8%AE%B0%E7%BB%99Hankqin%E8%BF%99%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E6%AC%A1%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>最近跟朋友聊了些关于技术的实践性，受到启发，于是将我的个人系统——Hankqin进行了一次小方面的改动，包括：将接口和页面升级为https、将页面全托管于腾讯云的cdn。</p><h2 id="升级Https"><a href="#升级Https" class="headerlink" title="升级Https"></a>升级Https</h2><p>  升级到https其实对我这个系统没多大影响，反正还有些不方便，但是我觉得还是值得的，毕竟在前端方面对安全的防范本就不够，能开的安全方式就给开了吧。<br>  升级过程是这样的，先申请证书，我一共申请了3个，阿里云2个，腾讯云1个，为什么阿里云需要2个呢，因为阿里云的免费证书只能绑定一个域名，而我接口有两个，而且我还不想合并，所以就申请了两个，分别对应<br>  <a href="https://api.hankqin.com" target="_blank" rel="noopener">https://api.hankqin.com</a>  和  <a href="https://music.hankqin.com" target="_blank" rel="noopener">https://music.hankqin.com</a><br>  腾讯云的那一个则对应cdn里的域名，分别是<br>  <a href="https://www.hankqin.com" target="_blank" rel="noopener">https://www.hankqin.com</a>  和  <a href="https://hankqin.com" target="_blank" rel="noopener">https://hankqin.com</a><br>  升级过程腾讯云其实还算简单，概括的说就是点点点就好了。<br>  阿里云因为是服务器端的，所以要下载证书，因为我用的Ngnix，所以配置如下：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server </span><br><span class="line">  &#123;</span><br><span class="line">      listen 443;</span><br><span class="line">      server_name api.hankqin.com; #填写绑定证书的域名</span><br><span class="line">      ssl on;</span><br><span class="line">      root html;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line">      ssl_certificate cert/cert-xxx_api.hankqin.com.crt;</span><br><span class="line">      ssl_certificate_key cert/cert-xxx_api.hankqin.com.key;</span><br><span class="line">      ssl_session_timeout 5m;</span><br><span class="line">      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">      ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">      ssl_prefer_server_ciphers on;</span><br><span class="line">      location / &#123;</span><br><span class="line">          proxy_pass http://xxx.xxx.xxx.xxx::7001;</span><br><span class="line">          proxy_redirect default;</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="托管CDN"><a href="#托管CDN" class="headerlink" title="托管CDN"></a>托管CDN</h2><p>这个实现起来其实很简单，但是值得一提的是托管到cdn后更新起来还是挺麻烦的，因为本身cdn的缓存就比较久，再配合代码自身的缓存，所以想实时看到修改后的效果还是有点困难。<br>不过全部托管也有好处，那就是流量全部交由腾讯云，这样一来方便统计数据二来给服务器减小了很多压力而且访问速度还大大提升，也算是得大于失吧。  </p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx 腾讯云 https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>travis-ci与博客</title>
      <link href="/2018/10/30/travis-ci%E4%B8%8E%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/10/30/travis-ci%E4%B8%8E%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>这次我分享下基于Travis CI完成个人博客的自动化构建的方法，同样的，网上资料已经一大堆了，具体的步骤就不过多书写，主要说点形而上的东西吧。</p><h2 id="为什么要用CI？"><a href="#为什么要用CI？" class="headerlink" title="为什么要用CI？"></a>为什么要用CI？</h2><p>如果你不能理解每次写完代码后打包上传这个过程有多繁琐你可能就不能理解为什么要用CI。<br>CI最大的作用就是解放双手，即使可能你今天没什么特别的事，不是特别忙，但是有了这段空闲时间你可以做更多你想做的事情，比如看看别人的博客，看看github上有什么热门项目。<br>CI还有一个很重要的功能是测试，自动化的测试说一就是一，不会乱来，所以当你有哪里不对时，CI是绝对不会让你通过的。</p><h2 id="自动化过程"><a href="#自动化过程" class="headerlink" title="自动化过程"></a>自动化过程</h2><p>我简单的列了一个使用CI后编写博客的过程，也分享出来让大家心里有个数：<br>ME  <strong>–&gt;</strong>  打开HEXO预览(hexo server) <strong> –&gt;</strong>  创建新文章(hexo new [layout] title)  <strong>–&gt;</strong>  编辑新内容(markdown)  <strong>–&gt;</strong>  排版错别字方面没问题(commit and push)  <strong>–&gt;</strong>  <strong>CI</strong>(接下来由CI负责)  <strong>–&gt;</strong>  编译(hexo g)  <strong>–&gt;</strong>  提交到master(commit and push)  </p><h2 id="一些教程"><a href="#一些教程" class="headerlink" title="一些教程"></a>一些教程</h2><p><a href="https://www.jianshu.com/p/e22c13d85659" target="_blank" rel="noopener">手把手教你使用Travis CI自动部署你的Hexo博客到Github上</a><br><a href="https://blog.csdn.net/xuezhisdc/article/details/53130423?utm_source=blogxgwz1" target="_blank" rel="noopener">hexo教程系列——使用Travis自动部署hexo</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实博客与自动化结合并没有提升多少效率，如果你不想写，神仙都拦不了你，只能说我用博客为引子，将自己带进自动化部署这个坑，有了这个成功先例，以后再更复杂的项目中做CI也不至于气馁到就此放弃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ci 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写可维护的js</title>
      <link href="/2018/03/01/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84js/"/>
      <url>/2018/03/01/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84js/</url>
      
        <content type="html"><![CDATA[<p>不知道身为前端er的你有没有过这种体验，几个月前写的代码自己某天回头再看，如果没有详细的注释，发现已经看不懂了，不知道到底是干嘛的了。<br>如果没有这种体验，那一定有过另一种体验：同事之前写的代码有些没有注释，完全看不懂。<br>所以说编写可维护的代码为什么要单独开一篇文章说明，就是因为它太重要了，甚至比如果编写js还重要。<br>今儿就把自己学习到的记录下来，时不时的查阅，看看自己到底有没有做到，也算是一种养成良好习惯的磨练吧。  </p><h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>这点就没什么好说的了。如果你是一个合格的前端er，你就会知道命名冲突究竟是多少蛋疼的事了。  </p><h2 id="如何访问全局对象"><a href="#如何访问全局对象" class="headerlink" title="如何访问全局对象"></a>如何访问全局对象</h2><p>我猜看到这里第一反应应该就是window吧，但是如果我的运行环境不是浏览器呢，这下又怎么办？<br>最好的办法应该是通过一段自执行的函数返回：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p><p>当然，很明显，严格模式下这段代码并不能返回你想要的结果(严格模式下函数的this指向undefined)</p><h2 id="单var形式"><a href="#单var形式" class="headerlink" title="单var形式"></a>单var形式</h2><p>这个形式有几个优点：  </p><ul><li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li><li>防止变量在定义之前使用的逻辑错误</li><li>少代码（类型啊传值啊单线完成）</li></ul><p>当然现在ES6出了let和const，有了块级作用域，为了防止变量提升，用let或const会比较好。<br>(不过使用时需要注意它们的暂时性死区)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">       b = <span class="number">2</span>,</span><br><span class="line">       sum = a + b,</span><br><span class="line">       myobject = &#123;&#125;,</span><br><span class="line">       i,</span><br><span class="line">       j;</span><br><span class="line">   <span class="comment">// function body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for循环大家都懂，但是按照书中的说法，如果简单使用<code>var i=0;i&gt;something.length;i++</code>，每次循环都会去找一个something，如果只是简单数组还好，如果循环的是DOM，那就非常糟糕了，要知道不论什么时候，使用DOM都是非常昂贵的。<br>再者是i++写法，JSLint推荐使用i+=1，解释是“避免过分棘手(excessive trickiness)”<br>所以完整下来应该就是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,max=something.length;i&lt;max;i+=<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">//something[i]...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="for-in枚举"><a href="#for-in枚举" class="headerlink" title="for-in枚举"></a>for-in枚举</h2><p>该方法用于对象的枚举，虽然数组也可以使用此方法(数组也是对象)，但并不推荐，原因是：  </p><blockquote><p>如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在for-in中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的for循环，对象使用for-in循环。  </p></blockquote><p>对象的循环本没有什么可说的，但是有个非常强大的东西——原型链，对象会继承原型链下的属性和方法，但常常我们不需要这些属性和方法，于是hasOwnProperty()方法就非常有用了，它:  </p><blockquote><p>函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回true，否则返回false。  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line">   <span class="keyword">if</span> (man.hasOwnProperty(i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">      <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种使用</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(man, i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">      <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果结合单var形式，写成这样是最优的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i, hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> man) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOwn.call(man, i)) &#123; <span class="comment">// 过滤</span></span><br><span class="line">        <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用switch"><a href="#使用switch" class="headerlink" title="使用switch"></a>使用switch</h2><p>可以通过类似下面形式的switch语句增强可读性和健壮性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inspect_me = <span class="number">0</span>,</span><br><span class="line">    result = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">switch</span> (inspect_me) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">   result = <span class="string">"zero"</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">   result = <span class="string">"one"</span>;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   result = <span class="string">"unknown"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>switch不仅能让代码看起来简洁，而且非常高高效。  </p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>具体的请参阅<a href="https://github.com/wangduanduan/js-best-parctices/tree/master/docs" target="_blank" rel="noopener">这篇文章</a><br>这里只大概列举几点：  </p><ul><li>驼峰式命名</li><li>变量名以名词开头</li><li>方法名以动词开头</li><li>常量全部大写</li><li>构造函数以大写字母开头</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>以前有写过一个关于写js的一些规范或者说是自己看完一些文章后的沉思吧，也一并放出来分享了。  </p><h3 id="一段好的代码应该是怎样的？"><a href="#一段好的代码应该是怎样的？" class="headerlink" title="一段好的代码应该是怎样的？"></a>一段好的代码应该是怎样的？</h3><p>试想，当你在学一个业务代码的时候，你是否想过如果参数不是我想要的会怎样、如果出现了异常错误会怎样、如果突然要改需求了会怎样、如果这个参数不存在会怎样，我想都是没有的，你只是关注了结果，却始终没有考虑过边界状态，没有考虑过异常、兼容性以及校验，这很糟糕，非常糟糕。<br>所以一段好的代码应该是怎样的呢？<br><strong>1.可用</strong></p><blockquote><p>必须确保自己写的代码是可以正常运行并得到想要的结果的，否则那就是无效代码. </p></blockquote><p><strong>2.健壮</strong></p><blockquote><p>①当存在参数或需要用户输入时，是否判断参数、用户输入存在？<br>②当参数或用户输入不符合要求时，是否做处理？<br>③当你使用的方法可能在别的浏览器不兼容时，是否做处理？</p></blockquote><p><strong>3.可靠</strong></p><blockquote><p>是否在所有情况下都能输出一个可靠的值？</p></blockquote><p><strong>4.宽容</strong></p><blockquote><p>①是否有足够的注释，让其他开发人员读懂？<br>②是否能在需求更改时快速更改而不需要大动干戈？<br>③当参数或用户输入不符合要求时，是否能将其转成可用参数？</p></blockquote><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>要求：编写一个javscript函数 fn，该函数有一个参数 n（数字类型），其返回值是一个数组，该数组内是 n 个随机且不重复的整数，且整数取值范围是 [2, 32]。</p><p>代码：</p><p><img src="D:\Hank\blog\images\example.png" alt="example"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说我理解的跨域</title>
      <link href="/2018/03/01/%E8%AF%B4%E8%AF%B4%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E8%B7%A8%E5%9F%9F/"/>
      <url>/2018/03/01/%E8%AF%B4%E8%AF%B4%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>作为一个前端er，跨域这方面的知识是必须掌握的，只是说究竟是完全理解透了还是只是在会用这个层面。<br>我的目标是把它理解透了，只有这样才能在碰到很复杂的问题时不至于无从下手。</p><h2 id="跨域是个啥"><a href="#跨域是个啥" class="headerlink" title="跨域是个啥"></a>跨域是个啥</h2><p>在上一篇文章里，我说了从输入一个url到回车究竟发生了什么，读过就知道实际上浏览器是从服务器上获取文件然后进行渲染解析等操作，按照这个过程，我浏览器是不是只要有地址就随便取别人服务器上的东西呢？<br>答案是否定的，相信作为一个从业者你也能想到，这一定会带来一些安全问题，浏览器自然也想到了，所以很久以前Netscape就提出了<strong>同源策略</strong>，定义是：  </p><blockquote><p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。  </p></blockquote><p>那么现在就有一个问题了，同源同源，那这个源到底是个啥玩意？<br>其实，源是由URI，主机名，端口号组合而成的。   <br><br>所以可想而知，在下面几种情况下资源不符合同源策略：  </p><ol><li>不同域名，如：<a href="http://www.hankqin.com" target="_blank" rel="noopener">http://www.hankqin.com</a> 和 <a href="http://www.qinhank.com" target="_blank" rel="noopener">http://www.qinhank.com</a></li><li>相同域名不同端口号，如：<a href="http://www.hankqin.com:8080" target="_blank" rel="noopener">http://www.hankqin.com:8080</a> 和 <a href="http://www.hankqin.com:8081" target="_blank" rel="noopener">http://www.hankqin.com:8081</a></li><li>同一个域名不同协议</li><li>主域和子域，如<a href="http://www.hankqin.com" target="_blank" rel="noopener">http://www.hankqin.com</a> 和 <a href="http://blog.hankqin.com">http://blog.hankqin.com</a></li><li>子域和子域，如<a href="http://blog.hankqin.com">http://blog.hankqin.com</a> 和 <a href="http://page.hankqin.com" target="_blank" rel="noopener">http://page.hankqin.com</a>  <br></li></ol><p>基于以上，跨域的定义也就自然出来了：  </p><blockquote><p>跨域，指的是浏览器不能执行其他网站的脚本。</p></blockquote><h2 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h2><p>知道了问题所在，就需要针对它做出相应的解决方案了。<br>常见的解决方案有：  </p><ol><li>JSONP</li><li>跨域资源共享(CORS)</li><li>document.domain+iframe（适用于主域名相同的情况）</li><li>window.name + iframe</li><li>postMessage（适用于两个iframe或两个页面之间）</li><li>location.hash + iframe（适用于两个iframe之间）  </li></ol><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>这个方案我想应该是目前用的最多的。它的原理很简单：<br>作为从业者基本都知道script、img、link标签实际上使用的是开发策略，所以实际上我们是可以随便引用非同源的脚本的，JSONP就是基于这个策略实现的，具体过程如下：  </p><ol><li>前后端约定特定字符为JSONP返回(一般使用callback)  </li><li>定义一个全局可访问的函数，参数即为服务器返回的数据，如:jsonpFn(data){}  </li><li>通过script标签执行函数，如:    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://baidu.com?callback=jsonpFn&amp;data=getJsonpData"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>自此，跨域完成，数据成功返回并运行。<br>但正如你所见，JSONP只支持GET方法，对于POST是无力的。  </p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>即跨域资源共享，关于这个更详细的说明请看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a>。<br>作为前端，实际上在CORS中需要做的不多，主要是后端。<br>浏览器CORS请求分成两种：  </p><ol><li>简单请求</li><li>协商模型/预检请求（Preflighted Request），即非简单请求  </li></ol><p>这两种有什么分别呢，又是怎么区分呢？<br>一般来说，只要满足亮点，那它就是简单请求，否则则为非简单请求：  </p><ol><li>请求方式为<strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong></li><li>HTTP的头信息子段</li></ol><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain，其中’text/plain’默认支持，其他两种则需要预检请求和服务器协商。</li></ul><p>其余的我不太想说了，实际应用中都会有些不够完美。<br>更多细节请<a href="https://zhuanlan.zhihu.com/p/25654664" target="_blank" rel="noopener">狂点我查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入一个URL到回车</title>
      <link href="/2018/02/28/%E4%BB%8E%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%88%B0%E5%9B%9E%E8%BD%A6/"/>
      <url>/2018/02/28/%E4%BB%8E%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAURL%E5%88%B0%E5%9B%9E%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p>网上很多版本，虽然大体没什么不同，但是我觉得还是不够详尽，很多地方只是提了，没有仔细说明，于是自己尝试开一个，按照自己所学到的整理一遍。</p><h2 id="你输入的这串英文我要转成数字"><a href="#你输入的这串英文我要转成数字" class="headerlink" title="你输入的这串英文我要转成数字"></a>你输入的这串英文我要转成数字</h2><hr><blockquote><p>当输入URL按下回车后，浏览器会根据域名查找其所对应的IP地址。  </p></blockquote><h4 id="问：那么什么是IP呢？这个IP最终指向哪里呢？"><a href="#问：那么什么是IP呢？这个IP最终指向哪里呢？" class="headerlink" title="问：那么什么是IP呢？这个IP最终指向哪里呢？"></a>问：那么什么是IP呢？这个IP最终指向哪里呢？</h4><ol><li>IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；  </li><li>根据第一点即可知道，这个IP指向的就是存放这个页面资源的电脑，我们称为服务器。   <br></li></ol><h4 id="问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？"><a href="#问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？" class="headerlink" title="问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？"></a>问：那么浏览器到底是怎么查找的呢？这个IP与域名的关系又是怎样的呢？</h4><p>一、查找过程</p><ol><li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；  </li><li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；  </li><li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；  </li><li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；  <ol><li>LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；  </li><li>LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；  </li><li>LDNS 向 baidu.com 域名服务器发起请求，得到 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的 IP 地址；  </li></ol></li><li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；  </li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；  </li><li>至此，浏览器已经得到了域名对应的 IP 地址。  </li></ol><p>二、IP与域名的关系  </p><ul><li>IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限；  </li></ul><h2 id="哈哈，我找到你在哪了"><a href="#哈哈，我找到你在哪了" class="headerlink" title="哈哈，我找到你在哪了"></a>哈哈，我找到你在哪了</h2><hr><blockquote><p>确定了服务器的 IP 地址后，浏览器便开始与服务器建立连接了。  </p></blockquote><p>当浏览器确定了服务器IP地址后，连接就正式开始啦。<br>服务器：可是，咱们萍水相逢，凭啥一上来就想看我包里装了什么？<br>客户端：既然如此，咱们就建立互相信任的关系吧。  <br></p><h4 id="建立连接-——-三次握手"><a href="#建立连接-——-三次握手" class="headerlink" title="建立连接 —— 三次握手"></a>建立连接 —— 三次握手</h4><ol><li>主机向服务器发送一个建立连接的请求（您好，我想认识您）；  </li><li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；  </li><li>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。  <br></li></ol><p>什么？就那么简单？NO，NO，NO，请<strong><a href="http://mp.weixin.qq.com/s/I41dnewpliUUU3VDNvPT1g" target="_blank" rel="noopener">查看这里</a></strong>详细了解这个过程。</p><h2 id="给我看看你背包里有什么吧"><a href="#给我看看你背包里有什么吧" class="headerlink" title="给我看看你背包里有什么吧"></a>给我看看你背包里有什么吧</h2><hr><blockquote><p>当服务器与主机建立了连接之后，主机便开始与服务器进行通信。  </p></blockquote><p>客户端：现在咱们的关系够铁了吧，来来来，看看你背包里有些啥玩意。<br>服务器：虽然我们很铁了，但是我爸爸说了，不能随便给别人看背包。<br>服务器：你说你想要啥，我拿给你。<br>客户端：。。。   <br></p><h3 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a><strong>网页请求与显示</strong></h3><ol><li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；    </li><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；  </li><li>服务器将得到的 HTML 文件发送给浏览器；  </li><li>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页；  </li><li>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；  </li></ol><p>网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。   </p><h2 id="东西拿到啦，我要开始干活啦"><a href="#东西拿到啦，我要开始干活啦" class="headerlink" title="东西拿到啦，我要开始干活啦"></a>东西拿到啦，我要开始干活啦</h2><hr><blockquote><p>在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页  </p></blockquote><p>客户端：哈哈哈哈，拿到我想要的东西啦，我现在开始干活了。  <br></p><h3 id="浏览器解析渲染数据"><a href="#浏览器解析渲染数据" class="headerlink" title="浏览器解析渲染数据"></a><strong>浏览器解析渲染数据</strong></h3><p>要说浏览器的解析渲染，首先咱们应该了解一下浏览器的内部组件。<br>浏览器内部拥有几个组件，包括UI后端、JS解释器、网络、浏览器引擎、渲染引擎以及其它异步引擎。<br>其中，UI后端的作用就是用来绘制类似组合选择框及对话框等基本组件，其具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。<br>当浏览器获得服务器的html文件后，会进行以下几个步骤：  </p><font size="4"><strong>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</strong></font>   <p>具体过程：</p><ol><li>渲染引擎开始解析html，并将标签转化为内容树中的dom节点  </li><li>解析外部CSS文件及style标签中的样式信息  </li><li>这些样式信息以及html中的可见性指令将被用来构建render树  <br><font color="gray">(Render树由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上)</font>  </li><li>Render树构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标  </li><li>接着浏览器开始绘制，即遍历render树，并使用UI后端层绘制每个节点。<br><font color="gray">(值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容)</font>  <br></li></ol><p>那么浏览器究竟是怎么构建DOM、Render树的呢？<a href="http://blog.csdn.net/baofeidyz/article/details/60479612" target="_blank" rel="noopener">点我查看更多知识噢</a>  </p><h2 id="天底下没有不散的宴席"><a href="#天底下没有不散的宴席" class="headerlink" title="天底下没有不散的宴席"></a>天底下没有不散的宴席</h2><hr><blockquote><p>客户端与服务器断开连接</p></blockquote><p>服务器：我爸叫我回家吃饭了，我赶走了<br>客户端：好<br>这时客户端犹豫了半刻。。。<br>客户端：你再等等，让我想想还有没有什么漏问了<br>服务器：。。。  <br></p><h3 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a><strong>断开连接–四次挥手</strong></h3><ol><li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；  </li><li>服务器接到请求后发送确认收到请求的信号（知道了）；  </li><li>服务器向主机发送断开通知（我也该走了）；  </li><li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；  </li></ol><p>补充：  </p><ul><li>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。  </li><li>第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 页面渲染过程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
